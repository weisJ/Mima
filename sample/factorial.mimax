#Compute the Factorial of a number.
#Works up to val = 10.
§define const val = 5;
§define x = 5, const y = 7, const w = 25;

LDC();
CALL(FACTORIAL);
Stop :
    HALT();

#Call point for computing the factorial.
#Parameter is stored in the accu.
FACTORIAL : {
    #Init
    §define argument = 0; #argument variable
    §define comp = 1; # 0
    §define neg_one = 2; # -1
    §define tmp = 3; #temporary variable

    STV();
    LDC(0);
    STV();
    LDC(-1);
    STV();
    LDC(1);
    STSP();
    #end init

    LDV();
    JMN(Stop); #Only positive numbers are valid

    CALL(COMPUTE_FAC);
    RET();

    COMPUTE_FAC : {
        #Check for base case
        EQL();
        JMN(BASE_FAC);

        CALL(INCREASE_STACK);

        #Compute factorial
        LDV();
        STVR(0, SP()); #store x

        LDC(-1);
        ADD();
        STV();
        CALL(COMPUTE_FAC); #compute (x-1)! =: y

        STVR(1, SP()); #store y
        CALL(MULT); #x * y

        CALL(DECREASE_STACK);
        RET();
    }

    #Base case 0! = 1
    BASE_FAC : {
        LDC(1);
        RET();
    }

    #Multiply two numbers x and y
    MULT : {
        LDVR(0, SP());
        EQL();
        JMN(MULT_RET);
        LDVR(2, SP());
        STV();
        LDVR(1, SP());
        ADD();
        STVR(2, SP());
        LDVR(0, SP());
        ADD();
        STVR(0, SP());
        JMP(MULT);

        MULT_RET : {
            LDVR(2, SP());
            RET();
        }
    }

    #Increase the factorial recursion stack.
    #Initialises all values in stack frame to 0
    INCREASE_STACK : {
        LDSP();
        ADC(3);
        STSP();
        LDC(0);
        STVR(0, SP());
        STVR(1, SP());
        STVR(2, SP());
        RET();
    }

    #Decrease factorial recursion stack.
    #Does not affect
    #accumulator value
    DECREASE_STACK : {
        STV();
        LDSP();
        ADC(-3);
        STSP();
        LDV();
        RET();
    }
}